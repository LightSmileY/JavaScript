# ES6 基础(1)

### ES6的开发环境搭建

**使用babel搭建环境的顺序：**

1. 创建项目创建两个文件夹src和dist

2. 使用npm init 初始化项目生成package.json（项目信息文件）

3. 使用 npm install -g babel-cli 全局安装

4. 使用 npm install –save-dev babel-preset-es2015 babel-cli本地安装

5. 创建.babelrc文件（babel转换的配置文件）

   ```json
   {    
       "presets":["es2015"],    
       "plugins":[]
   }
   ```

6. 在src下创建js，编写ES6语法

7. babel src/index.js -o dist/index.js转码生成ES5语法

**babel 本质就是一个 JavaScript 编译器**，通过：

1. 将 JavaScript 源代码解析成抽象语法树（AST）；
2. 将源代码的 AST 结果一系列转换生成目标代码的 AST；
3. 将目标代码的 AST 转换成 JavaScript 代码。

<br/>

------

### 新的变量声明方式

#### 1. let

##### 1.1 块级作用域

##### 1.2 暂时性死区

- 在一个块级作用域中，变量唯一存在，一旦在块级作用域中用let声明了一个变量，那么这个变量就唯一属于这个块级作用域，不受外部变量的影响

  ```javascript
  var tmp = 'bread and dream';
  if(true){
      tmp = 'dream or bread';   //ReferenceError
      let tmp;
  }
  // 在if块中的let对tmp变量进行了声明，导致该tmp绑定了这个作用域，而let临时死区导致了并不能在声明前使用，所以在声明前对变量赋值会报错。
  ```

- 暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。

- 暂时性死区的意义也是让我们标准化代码，将所有变量的声明放在作用域的最开始。

##### 1.3 不允许重复声明

<br/>

#### 2. const

##### 2.1 用于声明常量
##### 2.2 支持块级作用域
##### 2.3 不支持变量提升，有暂时性死区

##### 2.4 特殊情况——声明的常量是一个对象时，对象的属性是可以赋值的

- 对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量
- 但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针。

<br/>

### 3. import

- ES6采用import来代替node等的require来导入模块

  ```javascript
  import {$} from './jquery.js'
  ```

  ```javascript
  // 重命名
  import { JQ as $ } from './jquery.js';
  ```

- import命令具有提升效果，会提升到整个模块的头部，首先执行

<br/>

### 4. class

- ES6引入了类的概念，有了class这个关键字。不过类的实质还是函数对象。

- Class其实就是一个function，但是有一点不同，Class不存在变量提升，也就是说Class声明定义必须在使用之前。

<br/>

#### 总结

- ##### 在ES6之前，JavaScript是没有块级作用域的，如果在块内使用var声明一个变量，它在代码块外面仍旧是可见的。ES6规范给开发者带来了块级作用域，let和const都添加了块级作用域，使得JS更严谨和规范。

- ##### let 与 const 相同点：
  
  1. 块级作用域 
  2. 有暂时性死区  
  3. 约束了变量提升  
4. 禁止重复声明变量 

- ##### let 与 const不同点：
  
  1. const声明的变量不能重新赋值
  2. const变量声明时必须初始化

<br/>

------

### 解构赋值

- 按照一定的模式，从数组和对象中提取值，对变量进行赋值
- 使用解构赋值的特性，将会使等效的代码变得更加简洁并且可读性更高
- 本质上，这种写法属于“模式匹配”、“映射关系”

#### 1. 数组的解构赋值

```javascript
// ES6 之前
var a=1
var b=2
var c=3

// ES6 之后
let [a,b,c] = [1,2,3]
```

```javascript
// 对任意深度的嵌套数组进行解构
let [foo, [[bar], baz]] = [1, [[2], 3]]
```

```javascript
// 不需要匹配的位置可以置空
[,,third] = [1, 2, 3]
```

```javascript
// 使用...扩展运算符，匹配余下的所以值，形成一个数组
let [head, ...body] = [1, 2, 3, 4]
```



#### 2. 对象的解构赋值

```javascript
let { a, b } = { a: "111", z: "222" };
a // "111"
b // undefined

// 变量名与属性名不一致，可以改写成下面这样
let { a, z:b } = { a: "111", z: "222" };
a // "111"
b // "222"
```

```javascript
// 对任意深度的嵌套对象进行解构
let itemObj = {
   arr: [
     "aaa",
     { secondLevel: "bbb" }
   ]
}
let { arr: [firstLevel, { secondLevel }] } = itemObj
console.log(firstLevel) // "aaa"
console.log(secondLevel) // "bbb"
```

```javascript
// 自定义属性名称
let {name, id: ID} = { name: 'jack', id: 1  }
```



#### 3. 字符串解构

```javascript
const [a, b, c, d, e] = 'hello';
a // "h"
b // "e"
c // "l"
d // "l"
e // "o"

let { length：len } = 'hello';
console.log(len);  //5 (长度为5)
```



#### 4. 圆括号的用法

```javascript
// 在解构之前就已经定义了对象
let obj;
{obj}={obj:'James'};
console.log('James');  //报错

let obj;
({obj}={obj:'James'})
console.log('James')  //James
// JS引擎 就会认为 { obj } 是一个代码块，所以等号就出问题了，解决方式是在行首放个括号(，即外包裹一层括号（）
```



#### 5. 实际用途

- ##### 交换变量的值

  ```javascript
  let x = 1
  let y = 2
  [x, y] = [y, x]
  console.log(x)  //2
  console.log(y)  //1
  ```

- ##### 函数参数定义

  ```javascript
  // 参数是一组有次序的值
  function foo([width,height,left,right]) { 
      //... 
  }
  foo([100, 200, 300, 300])
  
  // 参数是一组无次序的值
  function foo({width,height,left,right}){
       // ...
  }
  foo([left:300, width:100, right:300, height:200,])
  ```

- ##### 配置对象参数

  ```javascript
  jQuery.ajax = function (url, {
        async = true,
        beforeSend = noop,
        cache = true,
        complete = noop,
        crossDomain = false,
        global = true,
        // ... 更多配置 
   }) {
        // ... 
   }
  ```

- ##### 从函数返回多个值

  ```javascript
  // 返回一个数组
  function foo() {
    return [1, 2, 3]
  }
  let [a, b, c] = foo()
  
  // 返回一个对象
  function foo2() {
    return {
      a: 1,
      b: 2
    }
  }
  let { a, b } = foo2()
  ```

- ##### 引入模块的指定方法

  ```javascript
  import { Loading} from 'element-ui'
  ```

<br/>

------

### 字符串模板引擎

#### 1. 多行字符串

```javascript
// 传统的JavaScript
var name = '黑子'
var age = 8
$('#result').append(
  '我的宠物狗叫 <b>' + name + '</b>\n' +
    '今年\n' +
    '<em>' + age+ '</em>岁，\n'+
  '十分可爱!'
)
```

```javascript
// ES6
let name = '黑子'
let age = 8
$('#result').append(
  `我的宠物狗叫 <b>${name}</b>
    今年 
    <em>${age}</em>岁，
  十分可爱!`
)
```



#### 2. 字符串中嵌入变量

```javascript
// ES5
const age = 8
const message  = '我的宠物狗叫黑子，今年' + age*2 + '岁了'

// ES6
const age = 8
const message  = `我的宠物狗叫黑子，今年 ${age*2} 岁了`
```

##### 既然占位符是JS表达式，还可以轻易嵌入运算符、函数调用等：

```javascript
const age = 8
const message = `我的宠物狗叫黑子，今年 ${(age*2).toFixed(2)} 岁了`

function fn() {
  return "小黄"
}
`我朋友家的宠物叫${fn()}`
```



#### 3. 带标签的模板字符串

##### 3.1 定义标签

```javascript
let  name = '黑子',
     age = 8,
     message = tag`我的宠物狗叫${name}，今年${age}岁了`;

function tag(stringArr, value1, value2) {
    console.log(stringArr);  //["我的宠物狗叫", "，今年", "岁了", raw: Array(3)]
                             //该数组有一个raw属性，保存的是转义后的原字符串
    console.log(value1);     // 黑子
    console.log(value2);     // 8
    return;
}

// 标签函数通常使用不定参数特性来定义占位符，从而简化数据处理的过程
function tag(stringArr, ...values) {
	console.log(values); //  ["黑子", 8]
}
```

##### 3.2 实际应用

- 过滤HTML字符串，防止用户输入恶意内容

  ```javascript
  let message =  filterHTML`<p>${sender} 你好啊</p>`
  function filterHTML(templateData) {
    let s = templateData[0]
    for (let i = 1; i < arguments.length; i++) {
      let arg = String(arguments[i])
      // 转义占位符中的特殊字符。
      s += arg.replace(/&/g, "&")
              .replace(/</g, "<")
              .replace(/>/g, ">")
      // 不转义模板中的特殊字符。
      s += templateData[i]
    }
    return s
  }
  
  // sender变量往往是用户提供的，经过filterHTML函数处理，里面的特殊字符都会被转义
  var sender = '<script>alert("买了个包")</script>' // 恶意代码
  var message = filterHTML`<p>${sender} 你好啊</p>`
  
  console.log(message)
  // <p><script>alert("买了个包")</script>  你好啊</p>
  ```

- 多语言转换

  ```javascript
  let name = 'ES6专栏 ';  let  number = 666;  
  let chinese = ['欢迎访问','您是第','位访问者']
  
  i18n`Welcome to ${name}, you are the ${number}  visitor`
  
  function i18n(stringArr, ...values){
      let str=''
      stringArr.map((item,index)=>{
          str += (chinese[index] +  (values[index] ? values[index] : '' ))   
      });
      console.log(str) 
  }
  //欢迎订阅ES6专栏 您是第666位访问者
  ```

  

#### 4. 新增的字符串方法

##### 4.1 查找字符串

```javascript
var msg = "Hello world!"

msg.startsWith("Hello")      // true
msg.endsWith("world!")       // true
msg.includes("d")            // true
```

```javascript
// 第二个参数后，includes 和 startsWith 会以该索引为起始点进行匹配
msg.includes("d", 8)          // true
msg.includes("d", 11)         // false
msg.startsWith("d", 10)       // true
msg.startsWith("d", 9)        // false
// endsWith 将字符串的长度与参数值相减并将得到的值作为检索的起始点
console.log(msg.endsWith("d", 11)         // true ( 长度13 - 参数值11 = 起始点2 )
console.log(msg.endsWith("d", 8)          // false ( 长度13 - 参数值8 = 起始点5 )
```

##### 应用场景

- 利用includes检查用户使用的浏览器

  ```javascript
  if (navigator.userAgent.includes('Chrome')) {
       console.log("是谷歌浏览器")
  } else {
        console.log("不是谷歌浏览器")
  }
  ```

- 利用startsWith检查路径

  ```javascript
  let urlstr = "http://www.baidu.com"
  let urlstr1 = "file:///C:/Users/xxx.html"
  console.log(urlstr.startsWith("https://"))    //false
  console.log(urlstr1.startsWith("file://"))     //true
  ```

- 利用startsWith检查文件格式

  ```javascript
  let path = "111.jpg"
  console.log(path.endsWith(".png"))   //false
  ```

##### 4.2 重复字符串

​	repeat方法，接受一个数字参数作为字符串的重复次数，返回一个重复包含初始字符串的新字符串

```javascript
console.log("abc".repeat(4))       // "abcabcabcabc"

let str = "小样儿"
console.log(str.repeat(5))     //小样儿小样儿小样儿小样儿小样儿
```

##### 4.3 填充字符串

​	string.padStart 往字符串前面填充

```JavaScript
let str = "Iphone"
let leftStr = "我的"
console.log(str.padStart(str.length + leftStr.length, leftStr))  //我的Iphone
```

​	string.padEnd 往字符串后面填充

```javascript
let iphone = "Iphone"
let rightStr = "10"
console.log(iphone.padEnd(iphone.length + rightStr.length, rightStr))  //Iphone10
```

