# 新的变量声明方式

### 1. let

##### 1.1 块级作用域

##### 1.2 暂时性死区

- 在一个块级作用域中，变量唯一存在，一旦在块级作用域中用let声明了一个变量，那么这个变量就唯一属于这个块级作用域，不受外部变量的影响

  ```javascript
  var tmp = 'bread and dream';
  if(true){
      tmp = 'dream or bread';   //ReferenceError
      let tmp;
  }
  // 在if块中的let对tmp变量进行了声明，导致该tmp绑定了这个作用域，而let临时死区导致了并不能在声明前使用，所以在声明前对变量赋值会报错。
  ```

- 暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。

- 暂时性死区的意义也是让我们标准化代码，将所有变量的声明放在作用域的最开始。

##### 1.3 不允许重复声明

<br/>

### 2. const

##### 2.1 用于声明常量

##### 2.2 支持块级作用域

##### 2.3 不支持变量提升，有暂时性死区

##### 2.4 特殊情况——声明的常量是一个对象时，对象的属性是可以赋值的

- 对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量
- 但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指向实际数据的指针。

<br/>

### 3. import

- ES6采用import来代替node等的require来导入模块

  ```javascript
  import {$} from './jquery.js'
  ```

  ```javascript
  // 重命名
  import { JQ as $ } from './jquery.js';
  ```

- import命令具有提升效果，会提升到整个模块的头部，首先执行

<br/>

### 4. class

- ES6引入了类的概念，有了class这个关键字。不过类的实质还是函数对象。

- Class其实就是一个function，但是有一点不同，Class不存在变量提升，也就是说Class声明定义必须在使用之前。

<br/>

#### 总结

- ##### 在ES6之前，JavaScript是没有块级作用域的，如果在块内使用var声明一个变量，它在代码块外面仍旧是可见的。ES6规范给开发者带来了块级作用域，let和const都添加了块级作用域，使得JS更严谨和规范。

- ##### let 与 const 相同点：

  1. 块级作用域 
  2. 有暂时性死区  
  3. 约束了变量提升  

4. 禁止重复声明变量 

- ##### let 与 const不同点：

  1. const声明的变量不能重新赋值
  2. const变量声明时必须初始化